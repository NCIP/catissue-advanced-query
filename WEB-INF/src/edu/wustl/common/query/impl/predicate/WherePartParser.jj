options
{
	STATIC = false;
	FORCE_LA_CHECK = true;
	DEBUG_PARSER = false;
	//DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(WherePartParser)

package edu.wustl.common.query.impl.predicate;

import java.io.*;


public class WherePartParser
{
	
	private PredicateGenerator predicateGenerator;
	private String forVariable;
	
	public WherePartParser(String wherePart, PredicateGenerator predicateGenerator)
	{
		this(new StringReader(wherePart));
		this.predicateGenerator = predicateGenerator;
	}
	
	
	public static void main(String[] args) throws ParseException, FileNotFoundException
	{
		InputStream in = new FileInputStream("WherePart4.txt");
		
		WherePartParser parser = new WherePartParser(in);
		parser.parse();
			
	}


}

PARSER_END(WherePartParser)

SKIP : {" " | "\t" | "\n" | "\r"}

TOKEN : { <DOLLAR : "$"> }
TOKEN : { <COMMA : ","> }
TOKEN : {<OPENING_PARENTHESIS : "(">}
TOKEN : {<CLOSING_PARENTHESIS : ")">}


TOKEN : { <PREFIX_UNARY_OPERATOR : "empty(" | "exists(" >}
TOKEN : { <PREFIX_BINARY_OPERATOR : "contains(string(" | "starts-with(string(" | "ends-with(string(" >}
TOKEN : { <INFIX_OPERATOR : ">=" | ">" | "<" | "<=" | "="  >}


TOKEN : { <LOGICAL_OPERATOR : "and" >}


TOKEN : { <CONDITION_ATTRIBUTE : <DOLLAR> (~[".", ")" , ">" , "<" , "=", " " , "\t" , "\n" , "\r"])* (".)")? > }


TOKEN : { <#DIGITS : (["0"-"9"])+  > }
TOKEN : { <#NUMBER :  <DIGITS> | <DIGITS> "." <DIGITS> | "." <DIGITS> | <DIGITS> "." >}
TOKEN : { <#STRING : "\"" (~["\""])* "\"" >}
TOKEN : { <CONSTANT : <STRING> | <NUMBER>  > }

TOKEN : { <FUNCTION_CALL : ("xs:" (~["("])*) "(" <CONSTANT> ")" >}




public void parse() throws ParseException:
{
	Token t = null;	
}
{
	ConditionTree() <EOF>
	{
		// System.out.println("Condition Tree Parsed Successfully!");	
	}
	
}



private void ConditionTree() :
{
	
}
{
	ConditionsOnOneEntity()
		
|
	ParenthesizedConditionsOnOneEntity()
	(<LOGICAL_OPERATOR>
	<OPENING_PARENTHESIS>
	ConditionsOnChild()
	<CLOSING_PARENTHESIS>)*
	
}

private void ParenthesizedConditionsOnOneEntity() :
{
	
}
{
	<OPENING_PARENTHESIS>
	ConditionsOnOneEntity()
	<CLOSING_PARENTHESIS>
	
}


private void ConditionsOnOneEntity() :
{
	AbstractPredicate predicate = null;
}
{
	predicate=AtomicCondition()
	{
		predicateGenerator.addPredicate(forVariable, predicate);	
	}
	
	(
		<LOGICAL_OPERATOR> predicate=AtomicCondition()
		{
			predicateGenerator.addPredicate(forVariable, predicate);
		}	
	)*
}



private AbstractPredicate AtomicCondition() :
{
	AbstractPredicate predicate = null;
}
{
	predicate=PrefixUnaryCondition()
	{
		return predicate;
	}
	
|

	predicate=PrefixBinaryCondition()
	{
		return predicate;	
	}
	
|

	predicate=InfixCondition()
	{
		return predicate;	
	}
	
|
	predicate=NegationCondition()
	{
		return predicate;	
	}
		
}


private AbstractPredicate PrefixUnaryCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
}
{
		operator = <PREFIX_UNARY_OPERATOR> 
		conditionAttribute=<CONDITION_ATTRIBUTE>
		<CLOSING_PARENTHESIS>
		{
			int separator = conditionAttribute.image.indexOf("/");
			forVariable = conditionAttribute.image.substring(0, separator);
			String attribute = conditionAttribute.image.substring(separator+1);
			AbstractPredicate predicate = new PrefixUnaryPredicate(attribute, operator.image);
			return predicate;				
		} 
	
}


private AbstractPredicate PrefixBinaryCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
	String rhs = null;
}
{
	operator=<PREFIX_BINARY_OPERATOR> 
	conditionAttribute=<CONDITION_ATTRIBUTE>
	<CLOSING_PARENTHESIS> <COMMA> 
	rhs = RHS()
	<CLOSING_PARENTHESIS>
	{		
		int separator = conditionAttribute.image.indexOf("/");
		forVariable = conditionAttribute.image.substring(0, separator);
		String attribute = conditionAttribute.image.substring(separator+1);
		AbstractPredicate predicate = new PrefixBinaryPredicate(attribute, operator.image, rhs);
		return predicate;
	}
	
}


private AbstractPredicate InfixCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
	String rhs = null;
}
{
	conditionAttribute=<CONDITION_ATTRIBUTE>
	operator=<INFIX_OPERATOR>
	rhs = RHS()
	{
		int separator = conditionAttribute.image.indexOf("/");
		forVariable = conditionAttribute.image.substring(0, separator);
		String attribute = conditionAttribute.image.substring(separator+1);
		AbstractPredicate predicate = new InfixPredicate(attribute, operator.image, rhs);
		return predicate;
		
	}

}

private AbstractPredicate NegationCondition() :
{
	AbstractPredicate predicate = null;
}
{
	"not(" 
	predicate=AtomicCondition()
	")"
	{
		AbstractPredicate negationPredicate = new NegationPredicate(predicate);
		return negationPredicate;	
	}
	
}


private void ConditionsOnChild() :
{
	
}
{
	ConditionTree()
	
}


private String RHS() :
{
	Token rhsToken = null;
	String rhs = null;
}
{
	rhsToken = <FUNCTION_CALL>
	{
	 	return rhsToken.image;
	} 
	
|
	rhsToken = <CONSTANT>
	{
	 	return rhsToken.image;
	} 
	
|
	rhsToken = <CONDITION_ATTRIBUTE>
	{
		return rhsToken.image;
	}
	
|
	 rhs = CSV()
	 {
	 	return rhs;
	 } 	
	
}


private String CSV() :
{
	StringBuilder rhs = new StringBuilder();
	Token constant = null;
}
{
	"("
	{
		rhs.append('(');	
	} 
	constant=<CONSTANT>
	{
		rhs.append(constant.image);
	}
	(
		<COMMA> constant=<CONSTANT>
		{
			rhs.append(',').append(constant.image);
		}
	)*
	")"
	{
		rhs.append(')');
		return rhs.toString();	
	} 
	
	
}	

