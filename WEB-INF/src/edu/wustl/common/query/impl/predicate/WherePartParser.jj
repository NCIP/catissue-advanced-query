options
{
	STATIC = false;
	LOOKAHEAD = 3;
	FORCE_LA_CHECK = true;
	DEBUG_PARSER = true;
	//DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(WherePartParser)

package edu.wustl.common.query.impl.predicate;

import java.io.*;


public class WherePartParser
{
	
	private PredicateGenerator predicateGenerator;
	private String forVariable;
	private StringBuilder xQueryWherePart = new StringBuilder();
	
	public WherePartParser(String wherePart, PredicateGenerator predicateGenerator)
	{
		this(new StringReader(wherePart));
		this.predicateGenerator = predicateGenerator;
		xQueryWherePart = new StringBuilder();
	}
	
	
	public static void main(String[] args) throws ParseException, FileNotFoundException
	{
		InputStream in = new FileInputStream("WherePartEmpty.txt");
		
		WherePartParser parser = new WherePartParser(in);
		parser.parse();
			
	}


}

PARSER_END(WherePartParser)

SKIP : {" " | "\t" | "\n" | "\r"}

TOKEN : { <DOLLAR : "$"> }
TOKEN : { <COMMA : ","> }
TOKEN : {<OPENING_PARENTHESIS : "(">}
TOKEN : {<CLOSING_PARENTHESIS : ")">}


TOKEN : { <PREFIX_UNARY_OPERATOR : "empty(" | "exists(" >}
TOKEN : { <PREFIX_BINARY_OPERATOR : "contains(string(" | "starts-with(string(" | "ends-with(string(" >}
TOKEN : { <INFIX_OPERATOR : ">=" | ">" | "<" | "<=" | "="  >}


TOKEN : { <LOGICAL_OPERATOR : "and" >}


TOKEN : { <CONDITION_ATTRIBUTE : <DOLLAR> (~[".", ")" , ">" , "<" , "=", " " , "\t" , "\n" , "\r", "["])* (".)")? > }


TOKEN : { <TEMPORAL_CONDITION_OPEN : "<TEMPORAL_CONDITION>" > :  IN_TEMPORAL_CONDITION }
<IN_TEMPORAL_CONDITION> TOKEN : { <CHAR : ~[]> }
<IN_TEMPORAL_CONDITION> TOKEN : { <TEMPORAL_CONDITION_CLOSE : "</TEMPORAL_CONDITION>" > : DEFAULT }



TOKEN : { <#DIGITS : (["0"-"9"])+  > }
TOKEN : { <#NUMBER :  <DIGITS> | <DIGITS> "." <DIGITS> | "." <DIGITS> | <DIGITS> "." >}
TOKEN : { <#STRING : "\"" (~["\""])* "\"" >}
TOKEN : { <CONSTANT : <STRING> | <NUMBER>  > }

TOKEN : { <FUNCTION_CALL : ("xs:" (~["("])*) "(" <CONSTANT> ")" >}
TOKEN : { <READYMADE_PREDICATE : "[" (~["]"])* "]" > }




public void parse() throws ParseException:
{
	Token t = null;	
}
{
	<EOF>
	{
		//System.out.println("EMPTY CONDITON PARSED SUCCESSFULLY !!");
	}
|	

	ConditionTree() <EOF>
	{
		//System.out.println("CONDITON PARSED SUCCESSFULLY !!");
		//System.out.println(xQueryWherePart);
		predicateGenerator.setXQueryWherePart(xQueryWherePart);	
	}
	
}



private void ConditionTree() :
{
	
}
{
	ConditionsOnOneEntity()
	(<LOGICAL_OPERATOR>
	JoiningCondition())*
	
		
|
	ParenthesizedConditionsOnOneEntity()
	(<LOGICAL_OPERATOR>
	ConditionsOnAChild())*
	
|
	ConditionsOnAChild()
	(<LOGICAL_OPERATOR>
	ConditionsOnAChild())*
	
	
}

private void ParenthesizedConditionsOnOneEntity() :
{
	
}
{
	<OPENING_PARENTHESIS>
	ConditionsOnOneEntity()
	<CLOSING_PARENTHESIS>
	
}


private void ConditionsOnOneEntity() :
{
	AbstractPredicate predicate = null;
}
{
	predicate=AtomicCondition()
	{
		if(predicate != null)
		{
			predicateGenerator.addPredicate(forVariable, predicate);
		}	
	}
	
	(
		<LOGICAL_OPERATOR> predicate=AtomicCondition()
		{
			if(predicate != null)
			{
				predicateGenerator.addPredicate(forVariable, predicate);
			}
		}	
	)*
}




private AbstractPredicate AtomicCondition() :
{
	AbstractPredicate predicate = null;
}
{
	predicate=PrefixUnaryCondition()
	{
		return predicate;
	}
	
|

	predicate=PrefixBinaryCondition()
	{
		return predicate;	
	}
	
|

	predicate=InfixCondition()
	{
		return predicate;	
	}
	
|
	predicate=NegationCondition()
	{
		return predicate;	
	}
	
|

	predicate=SelfPredicateCondition() 	
	{
		return predicate;	
	}
	
|

	TemporalCondition()
	{
		return null;
	}
	
}


private void TemporalCondition() :
{
	Token t = null;
}
{

	<TEMPORAL_CONDITION_OPEN>
	(
		t=<CHAR>
		{
			xQueryWherePart.append(t.image);
		}
		
|
		
		<TEMPORAL_CONDITION_CLOSE>
		{
			xQueryWherePart.append(" and ");
		}
	)+

}



private AbstractPredicate SelfPredicateCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
}
{
	conditionAttribute=<CONDITION_ATTRIBUTE>
	operator=<READYMADE_PREDICATE>
	{
			int separator = conditionAttribute.image.indexOf("/");
			forVariable = conditionAttribute.image.substring(0, separator);
			String attribute = conditionAttribute.image.substring(separator+1);
			AbstractPredicate predicate = new SelfPredicate(attribute, operator.image);
			return predicate;				
	} 



}



private AbstractPredicate PrefixUnaryCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
}
{
		operator = <PREFIX_UNARY_OPERATOR> 
		conditionAttribute=<CONDITION_ATTRIBUTE>
		<CLOSING_PARENTHESIS>
		{
			int separator = conditionAttribute.image.indexOf("/");
			forVariable = conditionAttribute.image.substring(0, separator);
			String attribute = conditionAttribute.image.substring(separator+1);
			AbstractPredicate predicate = new PrefixUnaryPredicate(attribute, operator.image);
			return predicate;				
		} 
	
}


private AbstractPredicate PrefixBinaryCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
	String rhs = null;
}
{
	operator=<PREFIX_BINARY_OPERATOR> 
	conditionAttribute=<CONDITION_ATTRIBUTE>
	<CLOSING_PARENTHESIS> <COMMA> 
	rhs = RHS()
	<CLOSING_PARENTHESIS>
	{		
		int separator = conditionAttribute.image.indexOf("/");
		forVariable = conditionAttribute.image.substring(0, separator);
		String attribute = conditionAttribute.image.substring(separator+1);
		AbstractPredicate predicate = new PrefixBinaryPredicate(attribute, operator.image, rhs);
		return predicate;
	}
	
}


private AbstractPredicate InfixCondition() :
{
	Token conditionAttribute = null;
	Token operator = null;
	String rhs = null;
}
{
	conditionAttribute=<CONDITION_ATTRIBUTE>
	operator=<INFIX_OPERATOR>
	rhs = RHS()
	{
		int separator = conditionAttribute.image.indexOf("/");
		forVariable = conditionAttribute.image.substring(0, separator);
		String attribute = conditionAttribute.image.substring(separator+1);
		AbstractPredicate predicate = new InfixPredicate(attribute, operator.image, rhs);
		return predicate;
		
	}

}

private AbstractPredicate NegationCondition() :
{
	AbstractPredicate predicate = null;
}
{
	"not(" 
	predicate=AtomicCondition()
	")"
	{
		AbstractPredicate negationPredicate = new NegationPredicate(predicate);
		return negationPredicate;	
	}
	
}


private void ConditionsOnAChild() :
{
	
}
{
	<OPENING_PARENTHESIS>
	ConditionTree()
	<CLOSING_PARENTHESIS>
	
}


private String RHS() :
{
	Token rhsToken = null;
	String rhs = null;
}
{
	rhsToken = <FUNCTION_CALL>
	{
	 	return rhsToken.image;
	} 
	
|
	rhsToken = <CONSTANT>
	{
	 	return rhsToken.image;
	} 
	
|
	rhsToken = <CONDITION_ATTRIBUTE>
	{
		return rhsToken.image;
	}
	
|
	 rhs = CSV()
	 {
	 	return rhs;
	 } 	
	
}


private String CSV() :
{
	StringBuilder rhs = new StringBuilder();
	Token constant = null;
}
{
	"("
	{
		rhs.append('(');	
	} 
	constant=<CONSTANT>
	{
		rhs.append(constant.image);
	}
	(
		<COMMA> constant=<CONSTANT>
		{
			rhs.append(',').append(constant.image);
		}
	)*
	")"
	{
		rhs.append(')');
		return rhs.toString();	
	} 
	
	
}


private void JoiningCondition() :
{
	AbstractPredicate predicate = null;
}
{
	<OPENING_PARENTHESIS>
	predicate=AtomicCondition()
	{
		if(predicate != null)
		{
			predicateGenerator.addPredicate(forVariable, predicate);
		}	
	}
	<CLOSING_PARENTHESIS>

}	

